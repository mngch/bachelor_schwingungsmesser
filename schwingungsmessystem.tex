\documentclass[12pt,a4paper]{scrartcl}

%========================================================================================
%SPRACHE

\usepackage[ngerman]{babel} 
\usepackage[T1]{fontenc} 				% richtige Silbentrennung
\usepackage[utf8]{inputenc}    % Umlaute etc.!!! BENUTZEN!!!!
\usepackage{float} % alles möglichen Sachen mit [h] an die richtige Stelle zwingen
%\usepackage{rotating} % tabellen rotieren
%\usepackage{supertabular} % schraege tabellen etc
%\usepackage{pdfpages}     % pdfs einbinden


\usepackage{setspace}

\usepackage[]{natbib}

%========================================================================================
%DARSTELLUNG

\usepackage[small,compact]{titlesec} 		% Verkleinerung von Section-Ueberschriften
\usepackage{graphicx}				  	% Einbinden von Graphiken .ps, .pdf, .png

\usepackage{amsmath}					% mathematische Symbole
%\usepackage {ulem} 						%\emph{Text}: Text wird unterstrichen
\setlength{\parindent}{0pt}				% Zeile nach Absatz einruecken 1pt oder nicht 0pt.

%========================================================================================
%FARBEN

\usepackage[usenames,dvipsnames]{color}	

									%Apricot 	Aquamarine 	Bittersweet 	Black
									%Blue 	BlueGreen 	BlueViolet 	BrickRed
									%Brown 	BurntOrange 	CadetBlue 	CarnationPink
									%Cerulean 	CornflowerBlue 	Cyan 	Dandelion
									%DarkOrchid 	Emerald 	ForestGreen 	Fuchsia
									%Goldenrod 	Gray 	Green 	GreenYellow
									%JungleGreen 	Lavender 	LimeGreen 	Magenta
									%Mahogany 	Maroon 	Melon 	MidnightBlue
									%Mulberry 	NavyBlue 	OliveGreen 	Orange
									%OrangeRed 	Orchid 	Peach 	Periwinkle
									%PineGreen 	Plum 	ProcessBlue 	Purple
									%RawSienna 	Red 	RedOrange 	RedViolet
									%Rhodamine 	RoyalBlue 	RoyalPurple 	RubineRed
									%Salmon 	SeaGreen 	Sepia 	SkyBlue
									%SpringGreen 	Tan 	TealBlue 	Thistle
									%Turquoise 	Violet 	VioletRed 	White
									%WildStrawberry 	Yellow 	YellowGreen 	YellowOrange
									
									% verwenden mit: 
									% \pagecolor{declared-color}
									% {\color{declared-color} text}
									% \colorbox{declared-color1}{\color{declared-color2} text}
									%========================================================================================
%Zur Einbindung von Programmiertexten mit:
				% \begin{lstlisting}
				%put your code here
				%\end{lstlisting}
				
\usepackage{listings}
\lstset{ %
language=C,                			% the language of the code
basicstyle=\footnotesize,       			% the size of the fonts that are used for the code
numbers=left,                   				% where to put the line-numbers
numberstyle=\footnotesize,      			% the size of the fonts that are used for the line-numbers
stepnumber=1,                   				% the step between two line-numbers. If it's 1, each line 
                                					% will be numbered			
commentstyle=\color{PineGreen},					
numbersep=-7pt,                  			% how far the line-numbers are from the code
backgroundcolor=\color{white},  		% choose the background color. You must add \usepackage{color}
showspaces=false,               			% show spaces adding particular underscores
showstringspaces=false,        		 	% underline spaces within strings
showtabs=false,                 				% show tabs within strings adding particular underscores
frame=single,                   				% adds a frame around the code
tabsize=2,                      				% sets default tabsize to 2 spaces
captionpos=b,                   				% sets the caption-position to bottom
breaklines=true,                				% sets automatic line breaking
breakatwhitespace=false,        			% sets if automatic breaks should only happen at whitespace
title=\lstname,                 				% show the filename of files included with \lstinputlisting;
                                					% also try caption instead of title
}
%========================================================================================


%LOAD FANCYHDR fuer Kopf- und Fu{\ss}zeilen
%\usepackage{fancyhdr}					% Paket laden	f\"ur einfache Handhabung von Kopf-und Fu{\ss}zeile
%\fancyhf{}								% alle Kopf- und Fu{\ss}zeilen bereinigen
%\pagestyle{fancy}						% Deklariere Seitenstil
%----------------------------------------------------------------------------------------------------------------------------------------------------------
% Angaben fuer Kopf-und Fu{\ss}zeilen links[L] und rechts[R]		
%\fancyhead[L]{{\textbf{Entwicklung eines Schwingungsmesssystems für ein Radar}}}
%\fancyfoot[C]{\thepage} 					% Seitennummer unten mittig

\usepackage[headsepline,plainheadsepline]{scrpage2}
\pagestyle{scrheadings}
\ihead[\rightmark]{\rightmark} \chead[]{}
\ohead[\pagemark]{\pagemark} \cfoot[]{}

\automark{section}
\renewcommand{\sectionmark}[1]{\markright{\ #1}}


\usepackage[small, nooneline, bf]{caption}

\addto\captionsngerman{
\renewcommand{\figurename}{Abb.}
\renewcommand{\tablename}{Tab.}
}

\usepackage{booktabs}
\usepackage{subfigure}



%==========================================================================================

\begin{document}

\title {Entwicklung eines Schwingungsmesssystems für ein Radar}
\author{Sebastian Beyer}
\maketitle

\newpage

\tableofcontents
\newpage




\section{Abstrakt}

\newpage

\section{Motivation}

\newpage

\section{Beschleunigungssensoren}
\onehalfspacing
Beschleunigungssensoren messen die Beschleunigung, die auf ein System wirkt, indem sie die auf eine Testmasse wirkenden Kräfte bestimmen. Nach Newton  Die auf einen Körper wirkende Beschleunigung setzt sich aus der Gravitation und Trägheitskräften zusammen. Isoliert man die Trägheitskräfte, so lässt sich daraus die Translationsbeschleunigung bestimmen. Mithilfe dieser und dem zweiten newtonschen Gesetz lässt sich die Positionsänderung des Systems berechnen: 

\begin{equation}
F = m \cdot a
\end{equation}

Es gibt verschiedene Prinzipien, mit denen Beschleunigung gemessen werden kann. Am gebräuchlichsten ist das der Federwaage.

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{federmasse.eps}
\caption{Masse-Feder-System zur Beschleunigungsmessung. k, d, m und $x$ bezeichnen Federkonstante, Dämpfung, Masse und Auslenkung. nach \citep{Klingbeil:2006qy}.}
\label{federwaage}
\end{figure}

Eine Masse m (auch seismische Masse genannt) ist über eine Feder der Federkonstanten k mit einem festen Bezugspunkt verbunden. Die Auslenkung $x$ ist proportional zur auf die Masse wirkenden Beschleunigung a.
\begin{equation}
a = \frac{k}{m} \cdot x
\end{equation}

Zu beachten ist die Ausrichtung des Sensors: a entspricht immer der Projektion der Beschleunigung auf die Auslenkungsrichtung von m.\\

Das System führt eine gedämpfte harmonische Schwingung aus. Einmal angeregt beginnt es zu schwingen, die Amplitude nimmt dann aber kontinuierlich ab. Die Bewegungsgleichung lautet: (vergleiche auch \citep{Meschede:2001fk})

\begin{equation}
m \ddot x + d \dot x + kx = 0
\end{equation}

Wobei $m$ die Masse, $d$ die Dämpfung und $k$ die Federkonstante ist.
Eine Lösung dieser Differentialgleichung lautet:

\begin{equation}
x(t) = x_0 e^{-\delta t} sin(\omega_d t + \varphi_0) \qquad mit \quad \delta = \frac{d}{2m}
\end{equation}

Die Lösung ist aus zwei elementaren Funktionen zusammengesetzt, wobei die eine den periodischen Anteil ausmacht und die andere den dämpfenden Anteil. Der periodische Anteil lässt ich auch als $x_0 e^{i\omega_d t}$ schreiben, wobei 
\begin{equation}
\omega_d = \sqrt{\omega_0^2 - \delta^2}
\end{equation}
die gedämpfte Eigenfrequenz genannt wird und einen entscheidenden Einfluss auf das Schwingverhalten hat.

Bei kleinem $\delta$ ist die Dämpfung gering und es gilt
\begin{equation}
\omega_d \approx \omega_0
\end{equation}
Dies nennt man den \textit{Schwingungsfall}

Wenn die Dämpfung jedoch so groß wird, dass
\begin{equation}
\delta = \omega_0
\end{equation}
gilt, wird $\omega_d = 0$ und das System kommt in kürzestmöglicher Zeit zur Ruhe. Man spricht vom \textit{aperiodischen Grenzfall}. Dieses Verhalten ist bei Beschleunigungsaufnehmern erwünscht, weil man so die höchste Wiederholfrequenz von Messungen erreicht, ohne dass sich die Anregungen gegenseitig überlagern.\\

Wird $\delta$ noch größer, so wird der Term unter der Wurzel negativ und $\omega_d$ damit imaginär. Aus 
\begin{equation}
e^{i\omega_d t}
\end{equation}
wird
\begin{equation}
e^{-k t}
\end{equation}
und bewirkt eine zusätzliche Dämpfung. Eine Schwingung existiert nicht mehr und das System erreicht seine Ruhelage nach längerer Zeit als beim aperiodischen Grenzfall. Dieses als \textit{Kriechfall} bezeichnete Verhalten ist in den meisten Fällen unerwünscht. \\



Mittlerweile sind Beschleunigungssensoren in den meisten Fällen als MEMS realisiert (\textbf{M}icro \textbf{E}lectro \textbf{M}echanical \textbf{S}ystems). Sehr kleine mechanische Elemente (1-100 Mikrometer) werden zusammen mit elektronischen Schaltungen auf einen Siliziumwafer aufgebracht. Dabei werden Techniken aus der Fabrikation von integrierten Schaltkreisen (ICs) verwendet. So können komplizierte elektromechanische System in winziger Größe und hoher Stückzahl hergestellt werden. Der geringe Preis ist maßgeblich dafür verantwortlich, dass die Sensoren in immer mehr Anwendungen integriert werden (Autos, Smartphones, Quadrokopter…).

Die Beschleunigungsmessung erfolgt also über die Messung der Auslenkung einer Testmasse. Dazu haben sich zwei Verfahren durchgesetzt, die ich im Folgenden kurz erläutern möchte. 

\subsection{Piezoresistive Sensoren}
Piezoresistive Sensoren machen sich den piezoelektrischen Effekt zunutze. In der Feder der Testmasse befinden sich Piezoelemente, welche sich bei Auslenkung verformen und damit ihren Widerstand ändern. Silizium ist ein geeignetes Material, da es sehr empfindlich und linear reagiert und gleichzeitig gut mit der MEMS Technik kombinierbar ist \citep{Kanda:1991gf}.

\subsection{Kapazitative Sensoren}

\begin{figure}[htb]
	\centering
	\subfigure[Sensor in Ruhe, Abstand der Kondensatorplatten ist gleich, $C_1 = C_2$] {
		\label{adxl_ruhe}
		\includegraphics[width=7cm]{adxl_ruhe.png}
	}
	\subfigure[Sensor während einer externen Beschleunigung, $C_1 < C_2$] {
	\includegraphics[width=7cm]{adxl_action.png}
 	\label{adxl_action}
	}
	\caption{Vereinfachtes Diagramm des ADXL05 \citep{Devices:1996pd}}
	\label{adxl}
\end{figure}

\begin{figure}[htb]
\centering
\includegraphics[scale=1]{adxl_micro.png}
\caption{ADXL05 unter dem Elektronenmikroskop, Beispiel für einen kapazitativen MEMS Beschleunigungssensor mit 46 Einzelzellen \citep{Klingbeil:2006qy}.}
\label{adxl_micro}
\end{figure}



Die Auslenkung lässt sich auch über eine Kapazitätsmessung bestimmen, wenn man je eine Elektrode an der Testmasse und am fixen Referenzpunkt anbringt \citep{S.J.-Sherman:1992ul}. Eine mögliche Realisierung ist in Abbildung \ref{adxl} a,b zu sehen: Es handelt sich um einen sogenannten Differentialkondensatorsensor \citep{:2002fk}. \\
Die seismische Masse befindet sich zwischen zwei fest verankerten Platten, die zusammen zwei Kondensatoren $C_1$ und $C_2$ bilden (Abb. \ref{adxl_ruhe}). Eine auftretende Beschleunigung führt also zu einer Auslenkung der Mittelelektrode des Kondensatorenpaares (seismische Masse) um die Länge $\pm x$ und damit zu einer symmetrischen Kapazitätsänderung um $\pm \Delta C$ (Abb. \ref{adxl_action}). Dieser Aufbau ist eine sogenannte Einzelzelle. In einem Sensor befinden sich viele Einzelzellen, um die Kapazitätsvariation und damit die Sensibilität zu erhöhen (Abb. \ref{adxl_micro}

Um diese Variation in ein elektrisches Ausgangssignal umzusetzen, wird eine sogenannte Brückenschaltung verwendet (Abb. \ref{bruecke}).

\begin{figure}[H]
\centering
\includegraphics[scale=2]{schaltung_beschleunigungssensor.png}
\caption{Brückenschaltung mit Differentialkondensator (Die mit $U_a$ verbundenen Elektroden von $C_1$ und $C_2$ bilden eine gemeinsame Platte) \citep{:2002fk}}
\label{bruecke}
\end{figure}

Die folgende Herleitung ist aus \citep{:2002fk} entnommen:

Wird eine Wechselspannung an die Brücke angelegt, so ergibt sich nach der Spannungsteilerregel für den Ausgang $U_a$:

\begin{equation}
U_a = U_1 - U_2 = U_0 \frac{R}{2 R} - U_0 \dfrac{\dfrac{1}{j \omega C_2} } { \dfrac{1} {j \omega C_2} + \dfrac{1}{j \omega C_1} }
\end{equation}

Durch Kürzen ergibt sich:

\begin{equation}
U_a = \frac{U_0}{2} - U_0 \dfrac{\dfrac{1}{C_2}}{\dfrac{1}{C_2} + \dfrac{1}{C_1}} = U_0 \left( \frac{1}{2} - \frac{C_1}{C_2 + C_1} \right) = \frac{U_0}{2} \left( \frac{C_2 - C_1}{C_2 + C_1} \right)
\end{equation}

Mit $C_1 = C_0 + \Delta C = \varepsilon _0 \cdot \varepsilon _r \cdot A / (d_0 - x )$ und $C_2 = C_0 - \Delta C = \varepsilon _0 \cdot \varepsilon _r \cdot A / (d_0 + x )$ erhält man eine lineare Abhängigkeit der Ausgangsspannung $U_a$ von der Auslenkung  $x$:

\begin{equation}
U_a = - U_0 \frac{x}{2 d_0}
\end{equation}\\


Diese Spannung lässt sich nun digitalisieren und auslesen. In vielen MEMS Bausteinen ist bereits ein integrierter Analog Digital Wandler eingebaut, sodass die Messwerte direkt digital abrufbar sind. 

\newpage

\section{Entwicklung des Schwingungsmesssystems: Prototyp (BMA180)}

Um abschätzen zu können wie groß die auftretenden Beschleunigungen an der Radarantenne sind, habe ich damit begonnen einen günstigen und einfach zu verwendenden Prototypen zu entwickeln. Letzteres ist vor Allem wichtig, um entscheiden zu können, für welchen Messbereich und welche Frequenzen der eigentliche Sensor ausgelegt sein muss. \\

\subsection{Bosch BMA180}
\begin{figure}[ht]
\centering
\includegraphics[scale=.4]{hardwareimages/bma180_breakout.jpg}
\caption{BMA180 Breakoutboard von Sparkfun}
\label{bma180_breakout}
\end{figure}

Die Wahl fiel auf einen digitalen, dreiachsigen MEMS Beschleunigungssensor \textit{Bosch BMA180}. Er verfügt über einen eingebauten 14-bit Analog-Digital Wandler und sieben per Software verstellbaren Messbereiche von $\pm1$ bis $\pm16$g.
Die Kommunikation kann über SPI (Serial Peripheral Interface)  oder I$^2$C (Inter-Integrated Circuit) erfolgen.

Ich nutze ein Breakoutboard von Sparkfun (Abb. \ref{bma180_breakout}), welches die IC Pins (SMD Technik) mit praktische Lötösen verbindet. Außerdem sind bereits zwei spannungsstabilisierende Kondensatoren mit auf der Platine verbaut.

\subsection{Arduino}

\begin{figure}[ht]
\centering
\includegraphics[scale=.2]{hardwareimages/ArduinoUno_R3_Front.jpg}
\caption{Arduino UNO}
\label{Arduino}
\end{figure}


Arduino ist eine auf ATmega Mikroprozessoren basierende Open-Source Entwicklungsplattform zur Verarbeitung von analogen und digitalen Signalen. Die Programmierung kann über eine eigene Entwicklungsumgebung in einer an \textit{Processing\footnote{processing.org}} angelehnten Sprache erfolgen, die im Prinzip ein vereinfachtes C/C++ darstellt.\\
Die Plattform ist auf Prototyping und Experimente ausgelegt. Es ist bereits ein Bootloader vorinstalliert, so kann die Programmierung direkt über die serielle Schnittstelle erfolgen. Die Boards machen die meisten Pins des ATmegas für eigene Schaltungen verfügbar, in den gängigen Boards sind das 14 Pins, die frei als Ein- oder Ausgänge genutzt werden können.
Die Stromversorgung kann über USB oder eine externe 5V Quelle erfolgen. Als Kommunikationsinterfaces werden SPI, ICSP (In-Circuit Serial Programming) und I$^2$C angeboten.\\
Der ATmega arbeitet mit 16 MHz und hat einen geringen Energieverbrauch.


\subsection{Schnittstellen}

\subsubsection{I$^2$C}
Zur Kommunikation zwischen Beschleunigungssensor und Arduino habe ich den  I$^2$C Bus \citep{:2012fj} gewählt.
Dabei handelt es sich um einen von Phillips entwickelten seriellen Datenbus, der ursprünglich entwickelt wurde, um Chips in Fernsehgeräten steuern zu können. Inzwischen ist das Patent ausgelaufen und er wird in vielen Hardwareprojekten verwendet, da er sehr einfach zu verstehen und zu verwenden ist. 

Ich benutze die Arduino Wire Library \citep{:2012vn}, welche die gesamte Kommunikation über I$^2$C steuert und einfache Funktionsaufrufe, wie zum Beispiel Senden und Empfangen, zur Verfügung stellt.

\subsubsection{Serieller Port}
Zum einfachen Anschluss des Arduinos an einen PC oder Datenlogger wird eine serielle Schnittstelle nach RS232 verwendet. Auf dem Arduino befindet sich ein ATmega16U2, welcher die seriellen Signale in USB umwandelt und dafür sorgt, dass der Arduino am PC als virtueller COM-Port erscheint.

\newpage
\subsection{Aufbau und Schaltung}

\subsubsection{Testaufbau}

Um die korrekte Verschaltung zu überprüfen und die Software für das Auslesen der Daten zu zu entwickeln, habe ich zunächst auf dem Breadboard gearbeitet. Der dazu verwendete Schaltplan ist in Abbildung \ref{schematics} zu sehen.

Da der Sensor sowohl im I$^2$C- sowie im SPI-Modus betrieben werden kann, ist es notwendig, den Modus bereits bei der Verschaltung einzustellen. Über den CS Pin (Pin 4) ist dies möglich. Schaltet man ihn auf High (3.3V), so benutzt der Chip I$^2$C, verbindet man ihn mit GND, so wird ISP verwendet. Je nach Modus haben die Pins unterschiedliche Funktionen. In Tabelle \ref{i2cmode} sind die verschiedenen Konfigurationen aufgeführt.

Pin 6 legt im von mir benutzten I$^2$C Modus die Adresse des Chips fest. Ist dieser auf Low (GND), so ist die Adresse 0x40.



\begin{figure}[htb]
	\centering
	\subfigure[Testaufbau auf dem Breadboard] {
		\label{breadboard}
		\includegraphics[width=7cm]{hardwareimages/breadboard.jpg}
	}
	\subfigure[Testplatine am Radar] {
	\includegraphics[width=7cm]{hardwareimages/testaufbau.png}
 	\label{testaufbau}
	}
	\caption{Testaufbau des Sensors}
	\label{testaufbaufigure}
\end{figure}


\begin{table}[htb]
\begin{tabular}{@{}lll@{}}      
    	\cmidrule(r){1-2}\morecmidrules\cmidrule(r){1-2}
       	Pin & SPI mode & I2C mode\\
      	\midrule
 	7 & SDI input & SDA birectional (!) \\ 
 	6 & SDO output & ADDR adress bit, input \\
 	5 & SCLK input & SCL input \\
 	4 & CSB chip select, input & I2C mode select, input \\
 	 \addlinespace
 	 \bottomrule
 \end{tabular}
\caption{BMA180 Pinbelegung für SPI und I$^2$C Modes \citep{Sensortec:2009rt}}
\label{i2cmode}
\end{table}


\begin{figure}[ht]
\centering
\includegraphics[scale=.6]{schematics.eps}
\caption{Schaltplan Testaufbau. Der Interrupt ist nicht verbunden, VDD und CS sind auf 3.3V geschaltet, GND und SDO auf die Masse des Arduinos gezogen, die I$^2$C Datenleitungen SCK und SDI sind mit den Arduinopins A4 und A5 verbunden, wobei zusätzlich 10k$\Omega$ Pull-Up-Widerstände eingebaut sind.}
\label{schematics}
\end{figure}


\newpage
\subsubsection{Fester Aufbau}

Um das System praktisch nutzen zu können muss es natürlich fest aufgebaut werden und mit einem Gehäuse versehen werden, das es erlaubt, ihn fest an einem Testobjekt anzubringen und ihn gleichzeitig vor Schäden durch mechanische oder witterungsbedingte Einflüsse schützt.

Um die eigentliche Sensoreinheit möglichst kompakt zu halten, habe ich mich entschieden, den Beschleunigungssensor vom Arduino zu trennen und auf eine kleine Lochrasterplatine zu löten. Diese wird in einen festen Block aus Polyurethanharz\footnote{OPTICALLY CLEAR POLYURETHANE, RS COMPONENTS, RS 195-984A} eingegossen, womit sie gleichzeitig gut geschützt und leicht anzubringen ist (Abb. \ref{harz}). \\

\begin{figure}[H]
\centering
\includegraphics[scale=.14]{hardwareimages/harz.jpg}
\caption{BMA180 in Polyurethanharz eingegossen, die Kunststoffform wurde von den feinmechanischen Werkstätten des Fachbereichs Geowissenschaften gefertigt.}
\label{harz}
\end{figure}

Der Arduino ist in ein ABS Gehäuse (zum Beispiel von BOSS Endloseres) eingebaut (Abb. \ref{arduinobox} und \ref{arduinoboxregen}
Die I$^2$C Verbindung mit dem Sensor erfolgt über einen Hirschmannstecker™ mit 7 Polen, von denen 4 beschaltet sind, wie in Abbildung \ref{hirschmann_i2c} zu sehen ist.
Mit dem Logger ist der Arduino über ein USB-Kabel verbunden, über das die Kommunikation per RS232 geführt wird.

\begin{figure}[ht]
\centering
\includegraphics[scale=.8]{hardwareimages/kabel.eps}
\caption{Verbindungen zwischen BMA180, Arduino und Logger per I$^2$C bzw. RS232}
\label{kabel}
\end{figure}

\begin{figure}[H]
	\begin{minipage}[H]{8cm}
		\centering
		\includegraphics[scale=.5]{hardwareimages/hirschmann_i2c.eps}
	\end{minipage}
	\hfill
	\begin{minipage}[H]{8cm}
		\centering
		\begin{tabular}{@{}lllll@{}}    
      			\cmidrule(r){1-5}\morecmidrules\cmidrule(r){1-5}
       			Pin & I2C & Arduino & BMA180 & Farbe\\
      			\midrule
 			1 & 3.3V & 3.3V & VDD & Rot \\ 
 			2 & & & &\\
 			3 & SDA & A4 & SDI & Gelb\\
 			4 & SCL & A5 & SCK & Grün\\
 			5 & & & &\\
 			6 & & & &\\
 			7 & GND & GND & GND & Schwarz\\
   			\addlinespace
   			\bottomrule
 		\end{tabular}
	\end{minipage}
	\caption{I$^2$C Beschaltung des Hirschmannsteckers™}
	\label{hirschmann_i2c}
\end{figure}


\begin{figure}[htb]
	\centering
	\subfigure[ABS Box, welche den Arduino enthält] {
		\label{arduinobox}
		\includegraphics[width=7cm]{hardwareimages/arduinobox.jpg}
	}
	\subfigure[ABS Box, geschlossen im Witterungstest] {
	\includegraphics[width=7cm]{hardwareimages/arduinoboxregen.jpg}
 	\label{arduinoboxregen}
	}
	\caption{ABS Box mit Arduino}
	\label{arduinoboxfigure}
\end{figure}


\subsection{Software} 

Die Software besteht aus zwei Teilen: Der Code auf dem Arduino fragt die Daten vom Sensor ab und stellt sie per RS232 zur Verfügung. Der zweite Teil auf dem Logger sammelt die Messungen über den Seriellen Port und schreibt diese gemeinsam mit der jeweils aktuellen Uhrzeit in eine Datei.\\

Bei der Erläuterung des Codes möchte ich mich auf die wesentlichen Punkte beschränken. Die vollständigen Quelltexte befinden sich im Anhang.

\subsubsection{Arduino}

Der Arduino ist für die Kommunikation mit dem BMA180 über I$^2$C zuständig. Für diese Aufgabe nutze ich die Arduino Bibliothek bma180\footnote{Selbst nach ausführlicher Recherche ist es mir nicht gelungen den Originalauthor der Bibliothek zu ermitteln. Ich habe sie von John Mc Combs, welcher allerdings nicht der Ursprungsauthor ist. \\ https://bitbucket.org/johnmccombs/arduino-libraries/src/058c7101c8da/bma180 (August 2012)}. Sie enthält eine Sammlung von Lese und Schreibroutinen, die ich für meine Zwecke angepasst habe.
Hier möchte ich die einzelnen Schritte beschreiben, die notwendig sind, um eine Messung zu erhalten und diese an den Logger weiterzuleiten. \\

Die Steuerung des BMA180 erfolgt über direkte Zugriffe auf die Register. Entweder schreibt man einen neuen Wert in ein Register oder man liest ein Register aus. Es gibt fünf Arten von Registern - \texttt{test}, \texttt{control}, \texttt{image}, \texttt{status} und \texttt{data}.
Davon interessieren uns nur die \texttt{control} und die \texttt{data} Register. Weitere Informationen über die zusätzlichen Register lassen sich im Datenblatt \citep{Sensortec:2009rt} nachschlagen.

Die \texttt{control} Register dienen dazu, den Beschleunigungssensor zu steuern, vornehmlich also den Messbereich festzulegen und eventuell einen zusätzlichen digitalen Bandfilter einzustellen. Dazu müssen Werte in Register hineingeschrieben werden. Dazu geht man folgendermaßen vor:\\

\textbf{In Register schreiben}
\begin{enumerate}
	\item Übertragung initiieren (mit der Adresse des Sensors)
	\item Adresse des Registers senden, in welches wir schreiben möchten
	\item Daten senden, die wir in das Register schreiben möchten
	\item Übertragung beenden
\end{enumerate}

Da ein Register immer ein Byte (8 Bit) groß ist, finden sich oftmals verschiedene Einstellungen in einem Register um Platz zu sparen. Einen korrekten Schreibvorgang auszuführen wird dadurch komplexer. Daher möchte ich den Prozess am Beispiel der Messbereichseinstellung demonstrieren.

\begin{figure}[H]
%\centering
\includegraphics[scale=.359]{registerstransp}
\caption{Memory Map BMA180, Ausschnitt \citep{Sensortec:2009rt}}
\label{registermap}
\end{figure}

Die relevanten Bits befinden sich im Register \texttt{0x35}\footnote{Ein vorangestelltes \texttt{0x} bedeutet, dass es sich um eine Zahl im Hexadezimalsystem handelt}, Bit eins, zwei und drei\footnote{Es wird von rechts nach links gezählt und mit 0 begonnen} (siehe Abb. \ref{registermap} Hier die entsprechenden Zeilen aus dem Quellcode:

\lstset{language=C++,caption={Funktion zum Einstellen des Messbereichs aus der bma180 Bibliothek\\ maxg ist eine dem Wertebereich zugeordnete Binärzahl zwischen 000 und 110 },label=sensitivity}
\lstset{frameround=fttt}
\begin{lstlisting}[frame=trBL]
	void BMA180::setGSensitivty(GSENSITIVITY maxg) //1, 1.5 2 3 4 8 16
	{
	    setRegValue(0x35,maxg<<1,0xF1);
	    gSense = maxg;
	}
\end{lstlisting}
 
Die aufgerufene Funktion $setRegValue$ (Zeile 3) bekommt als Argumente das zu schreibende Register (\texttt{0x35}), den zu schreibenden Wert ($maxg << 1$) und zusätzlich eine Maske, die angibt, welche Bits des Registers nicht(!) verändert werden sollen.\\
Da das letzte Bit (Bit Null) eine andere Funktion hat, 'schieben' wir $maxg$ mit Hilfe der \textit{bitshift Operation} $<<$ um ein Bit nach links.\\
Bei $gSense$ (Zeile 4) handelt es sich um eine Statusvariable, die später benutzt wird, um den genutzten Wertebereich mit zu dokumentieren.\\


\lstset{language=C++,caption={Funktion zum Schreiben eines Registers aus der BMA180 Bibliothek(REF!!)},label=writeregister}
\begin{lstlisting}[frame=trBL]
	void BMA180::setRegValue(int regAdr, int val, int maskPreserve)
	{
	    int preserve=getRegValue(regAdr);	
	    int orgval=preserve & maskPreserve;
	    Wire.beginTransmission(address);
	    Wire.write(regAdr);
	    Wire.write(orgval|val);
	    int result = Wire.endTransmission();
	    checkResult(result);
	}
\end{lstlisting}

Nun lesen wir zunächst den bisherigen Wert des Registers ein (Zeile 3)  und maskieren ihn mit der übergebenen Maske, so dass wir alle Bits übernehmen, außer die, welche wir verändern wollen (Zeile 4). Dann schreiben wir in das Register, wobei wir nach dem oben beschriebenen Schema vorgehen. Beim Senden der Daten verknüpfen wir jedoch $orgval$ mittels eines bitweisen $OR$ mit dem zu schreibenden Wert (Zeile 7). So haben wir sichergestellt, dass wir nur die relevanten Bits verändern.\\
In Abbildung \ref{bitops} ist das Vorgehen noch einmal dargestellt.

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{bitops.eps}
\caption{Beispiel eines Schreibvorgangs in das Register \texttt{0x35}. Nur die grau markierten Bits werden verändert.}
\label{bitops}
\end{figure}

\textbf{Daten aus Registern lesen}

In die data Register werden die gemessenen Beschleunigungsdaten geschrieben. Da der A/D-Wandler des BMA180 eine Auflösung von 14 Bit hat, existieren pro Achse 2 Register mit jeweils 8 Bit. 
Hier benötigen wir das Konzept der \textbf{Bitwertigkeit}:

In einer Zahl haben die Stellen unterschiedlichen Wert. Verändert man zum Beispiel bei der Zahl 4650 die letzte Stelle, so ist der Unterschied maximal 9 (4650 verglichen zu 4659). Wird hingegen die dritte Stelle (von hinten) verändert, so kann der Unterschied bis zu 900 betragen. Analog verhält es sich mit den binären Zahlen. 
Dabei bezeichnen wir das höchstwertige Bit als \textbf{m}ost-\textbf{s}ignificant-\textbf{b}it \textbf{(msb)} und das geringwertige Bit als \textbf{l}east-\textbf{s}ignificant-\textbf{b}it \textbf{(msb)}.

Analog dazu spricht man vom höchstwertigen Byte \textbf{m}ost-\textbf{s}ignificant-\textbf{b}yte \textbf{(MSB)} und geringwertigen Byte \textbf{l}east-\textbf{s}ignificant-\textbf{b}yte \textbf{(LSB)}.

\begin{equation}
\overbrace {\underbrace{1}_{msb}000101101}^{MSB}\overbrace {11010011\underbrace{0}_{lsb}}^{LSB}
\end{equation}

Die gemessene Beschleunigung ist also aufgeteilt und muss im Programm wieder zusammengesetzt werden. \\

Um die Beschleunigungsdaten vom Sensor zu laden, ist so vorzugehen:
\begin{enumerate}
	\item Übertragung initiieren (mit der Adresse des Sensors)
	\item Adresse des Registers senden, bei dem wir \textbf{anfangen} wollen zu lesen
	\item Übertragung beenden
	\item So viele Bytes abrufen, wie wir haben möchten
	\item Übertragung beenden
\end{enumerate}

\lstset{language=C++,caption={Funktion zum Auslesen der Beschleunigungsdaten, x,y,z sind 2 Byte Integerzahlen},label=readaccel}
\begin{lstlisting}[frame=trBL]
	void BMA180::readAccel()
	{
	  unsigned int result;

	  Wire.beginTransmission(address);
	  Wire.write(0x02);
	  Wire.endTransmission();
	  Wire.requestFrom((int)address, 7);
	  if(Wire.available()==7)
	  {
	    int lsb = Wire.read()>>2;
	    int msb = Wire.read();
	    x=(msb<<6)+lsb; 
	    if (x&0x2000) x|=0xc000; // set full 2 complement for neg values
	    lsb = Wire.read()>>2;
	    msb = Wire.read();
	    y=(msb<<6)+lsb;
	    if (y&0x2000) y|=0xc000;
	    lsb = Wire.read()>>2;
	    msb = Wire.read();
	    z=(msb<<6)+lsb;
	    if (z&0x2000) z|=0xc000;
	    temp = Wire.read();
	    if (temp&0x80) temp|=0xff00;
	  }
	  result = Wire.endTransmission();
	}
\end{lstlisting}

Das Register, bei dem wir beginnen wollen zu lesen, ist \texttt{0x02}, (Zeile 6) und wir benötigen die nächsten 7 Bytes (Zeile 8). Jeweils zwei Bytes MSB und LSB für die drei Achsen und als letztes Byte lesen wir zusätzlich die aktuelle Temperatur aus. Diese wird jedoch im Weiteren nicht verwendet.\\

Mit $Wire.requestFrom(adress, n)$ fordern wir einen Stapel von $n$ Bytes vom Sensor (Zeile 8). $Wire.read()$ entfernt immer das oberste Byte von diesem Stapel und gibt seinen Wert aus. Da das LSB an Stelle null und eins für den Messwert nicht relevante Bits enthält, entfernen wir diese per Bitshift (Zeile 11). Dann shiften wir das MSB im ganzen um sechs Stellen nach links, um es dann mit dem LSB zu addieren und damit den kompletten Messwert zu erhalten (Zeile 13).\\

Da die Daten im sogenannten Zweierkomplement (näheres in \citep{Tietze:2002fk}) ausgegeben werden und es sich bei x (sowie bei y und z) um Integer Variablen handelt, müssen wir das Vorzeichenbit an vorderster Stelle setzen. Dies geschieht in Zeile 14 (bzw. Zeile 18 für y und Zeile 24 für z).\\



\begin{figure}[H]
\centering
\includegraphics[scale=.6]{auslesen.eps}
\caption{Auslesen und zusammenfügen der Daten. MSB und LSB werden addiert. Mittels IF Abfrage und Masking wird überprüft, ob es sich um eine negative Zahl handelt; Falls ja, so wird das korrekte Zweierkomplement gebildet und als Integer gespeichert.}
\label{auslesen}
\end{figure}


\subsubsection{Restitution}

Jetzt haben wir eine Beschleunigungsmessung, jedoch ist diese noch in gerätespezifischen 'count' Einheiten. Diese müssen nun die physikalisch bestimmte Einheit der Beschleunigung umgerechnet werden. Der Vorgang wird als Restitution bezeichnet und der entsprechende Code ist in Listing \ref{restitution} zu sehen.

\lstset{language=C++,caption={Restitution der aufgenommenen Beschleunigungsdaten. Ausgabe als Vielfaches von der Erdbeschleunigung $g = 9.81m/s^2$},label=restitution}
\begin{lstlisting}[frame=trBL]
	float BMA180::getXValFloat()
	{
	    // normalize (if x is maximum (8191) and GSENSE=1.0 then 1.0
	    return (float)x/8191.0*getGSense();
	}
\end{lstlisting}

Aus dem Datenblatt \citep{Sensortec:2009rt} lässt sich entnehmen, dass $10~0000~0000~0000$ den geringstmöglichen Wert in jedem Messbereich darstellt und $01~1111~1111~1111$ de größten. Das erste Bit gibt dabei das Vorzeichen an (Zweierkomplement). Teilt man den Wert durch 8191, was in Binärdarstellung $1~1111~1111~1111$ entspricht, erhält man nach einer Multiplikation mit dem Messbereich (GSENSE) die Beschleunigung als Vielfaches der Erdbeschleunigung $g = 9.81 m/s^2$.


\subsubsection{PC Logger}

Das Programm, welches auf dem PC läuft und die Daten aufzeichnet, ist ein Python Script, welches ich von Matthias Hort übernommen und angepasst habe. Sobald es gestartet ist und eine kurze Beschreibung für das aktuelle Experiment eingegeben wurde, nimmt es sämtliche Nachrichten auf dem eingestellten Comport entgegen und schreibt diese mit der jeweils aktuellen Systemzeit in eine Datei.

Die exakte Zeit ist sehr wichtig, um die Ergebnisse später mit anderen Messungen vergleichen zu können. Zu diesem Zweck ist der PC mit einem NTP (Network Time Protocol) Server verbunden, welcher stets die korrekte Uhrzeit von GPS-Satelliten empfängt und im Netzwerk zur Synchronisation bereitstellt. Ein Programm auf dem PC (Domain Time II) korrigiert mit dieser GPS Zeit die computerinterne Uhr.



\section{Experimente in Waakirchen}

Um das System in der Anwendung zu testen, habe ich im Mai 2012 an Eruptionsdynamikexperimenten in Waakirchen, in der Nähe von München, teilgenommen. Diese Experimente wurden gemeinsam mit der Ludwig-Maximilians-Universität München, der Universität Catania und dem Istituto Nazionale di Geofisica e Vulcanologia (Sezione di Catania and Dept. of Seismology and Tectonophysics, Rome) durchgeführt. 

Bei diesen Experimenten wurden künstliche Explosionen in Autoklaven \citep{Spieler:2004fk} verschiedener Geometrie (von 16 cm bis 40 cm Länge) ausgelöst. Es kamen dabei zwei Aufbauten zum Einsatz, von denen einer das Erhitzen der Proben auf bis zu $850\circ C$ und damit der Wirklichkeit nähere Umgebungsbedingungen ermöglichte. Bei den verwendeten Samples handelte es sich um Proben von verschiedenen Vulkanen (sowohl Asche als auch festes Lavagestein) und Analogmaterialien.
Die Experimente wurden wiederholt durchgeführt und dabei potentielle Einflussgrößen wie Korngröße, Mischverhältnis, Druck und Temperatur variiert.

Untersucht wurde dabei eine Vielzahl von Parametern durch den Einsatz von Hochgeschwindigkeits- Thermo- und optischen Kameras, Piezo Sensoren, einem akustischen Array und unserem Doppler Radar.\\

Mein Ziel war dabei vor Allem, den Prototypen im Feld zu testen und Informationen über die Größenordnung der an der Radarantenne auftretenden Geschwindigkeiten zu gewinnen. Zusätzlich wollte ich die Bewegung des Autoclavenaufbaus untersuchen, da bei vorherigen Experimenten in den Radardaten in einigen Fällen negative Geschwindigkeiten auftraten, für die es bisher keine vollständige Erklärung gibt. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ergebnisse der Messungen in Waakirchen}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{wakiki/firstexample2.png}
\caption{Restituierte Beschleunigungsdaten in 3 Komponenten während Experiment 7.\\ Die X-Achse entspricht der Querachse (Nickachse) des Radars, die Y-Achse seiner Hochachse und die Z-Achse der Längsachse, welche in Radarstrahlrichtung ausgerichtet ist. }
\label{firstexample}
\end{figure}



zeitvergleich mit Radar

Eruption ist zu sehen! YEAH!



Schüssel bewegt sich um x m/s durch Explosion! Im auflösbaren Bereich? 


Integration Integrationsproblem


Korrelation zwischen Geschwindigkeit (Radargemessen) und gemessener Beschleunigung? 
sieht schlecht aus…

Experiment am Tisch


\section{Verbesserungen}

BMA180 - Interrupts benutzen, da sonst Samples verlorengehen… etc



\newpage
\section{Entwicklung des Schwingungsmesssystems: ASC 5511LN-002}


Mit den bisher gewonnenen Erkenntnissen konnte ich nun das zweite Schwingungsmesssystem mit dem ASC Chip (ASC 5511LN-002) realisieren. Durch die höhere Auflösung und Samplerate und geringeres Rauschen, ergibt sich ein besser nutzbares Signal. Einen Vergleich der relevanten technischen Daten enthält Tabelle \ref{sensorcompare}.

\begin{table}[ht]
\begin{tabular}{@{}llll@{}}    
      			\cmidrule(r){1-4}\morecmidrules\cmidrule(r){1-4}
       			Beschleunigungsaufnehmer & Auflösung & Noise & Temperatur Drift\\
      			\midrule
 			BMA180 				   & 0.244 mg  & 150$\mu g / \sqrt{Hz}$ & 0.5 $mg/k$ \\ 
 			ASC 5511LN-002 		   & 0.077 mg  &    5$\mu g / \sqrt{Hz}$  & 0.2 $mg/k$\\
 		
   			\addlinespace
   			\bottomrule
 \end{tabular}
 \caption{Vergleich der relevanten technischen Daten der beiden Sensoren bezogen auf einem Messbereich von $\pm$2g.\\ Das Auflösungsvermögen des ASC 5511LN-002 bezieht sich hier auf die Verwendung mit  dem \textit{Diamond-MM-16-AT PC/104 Analog I/O Module}}
 \label{sensorcompare}
\end{table}

\subsection{ASC 5511LN-002}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{hardwareimages/asc.jpg}
\caption{ASC 5511LN-010 von Advanced Sensors Calibration}
\label{asc5511}
\end{figure}

Bei dem ASC 5511LN-002 handelt es sich ebenfalls um einen kapazitativen MEMS Sensor. Er ist allerdings von hochwertigerer Qualität als der BMA180 und gibt das Signal analog als Spannung aus. Aus diesem Grund wird ein externer AD-Wandler benötigt.
Durch das Aluminiumgehäuse ist die Elektronik bereits gut geschützt und die symmetrische Ausführung der Signalkabel sorgt dafür, dass äußere elektromagnetische Einflüsse auf dem Weg zum AD-Wandler vermieden werden. Das Signal wird als auf zwei Leitungen ausgegeben, wobei das Signal auf der einen Leitung invertiert ist (Abb. \ref{symmetrisch}). Störungen wirken auf beide Adern und somit kann man sie an der Empfangsstation per Differenzbildung leicht entfernen. 
\begin{figure}[H]
\centering
\includegraphics[scale=.7]{unsymmetrisch.png}
\caption{Unsymmetrische Signalübertragung mit Störung 'Zacke'. \citep{Sengpiel:2001fk}}
\label{unsymmetrisch}
\end{figure}


Bei unsymmetrischer Signalführung wird das Störsignal ebenso stark verstärkt, wie das Nutzsignal (Abb. \ref{unsymmetrisch}). Mathematisch lässt sich dies so ausdrücken \citep{Sengpiel:2001fk}:

\begin{equation}
U_a = v \cdot (U_e + U_{stoer} = v \cdot U_e + v \cdot U_{stoer}
\end{equation}

wobei $U_a$ dem Ausgangssignal, $U_e$ dem Eingangssignal, $U_stoer$ dem Störsignal und $v$ dem Verstärkungsfaktor entspricht.

\begin{figure}[H]
\centering
\includegraphics[scale=.7]{symmetrisch.png}
\caption{Symmetrische Signalübertragung mit sich aufhebender Störung. \citep{Sengpiel:2001fk}}
\label{symmetrisch}
\end{figure}

Symmetrische Signalführung hingegen sorgt dafür, dass sich der Störeinfluss auslöscht:

\begin{equation}
U_a = U_e + U_{stoer} - ( -U_e + U_{stoer} ) = 2 \cdot U_e
\end{equation}

Das Resultat ist ein besseres Signal zu Rausch Verhältnis.


\subsection{Diamond-MM-16-AT PC/104 Analog I/O Module}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{hardwareimages/diamondmm16at.jpg}
\caption{Diamond-MM-16-AT PC/104 Analog I/O Module}
\label{diamond}
\end{figure}



Als AD-Wandler verwende ich ein \textit{Diamond-MM-16-AT PC/104 Analog I/O Module}. Das Board verfügt über 8 Eingänge (16 wenn man sie nicht als Differentialeingänge verwendet) und eine maximale Samplingrate von 100kHz. Außerdem besitzt es einen 512-Sample \textit{FIFO Speicher} und verwendet \textit{Interrupts}, worauf ich in den beiden nächsten Punkten eingehen möchte.
Mit dem Computer verbindet sich das Board über den \textit{PC/104 Bus}.


\subsubsection{Interrupts}

\begin{figure}[H]
\centering
\includegraphics[scale=1.4]{interrupt.png}
\caption{Ablauf eines Interrupts \citep{Stallings:2000uq}}
\label{interrupt}
\end{figure}

Ein Interrupt beschreibt in der Informatik eine kurzzeitige Unterbrechung des normalen Programmflusses, um eine andere Operation auszuführen. Diese andere Operation ist Zeitkritisch und ihr exaktes Auftreten nicht vorher bestimmbar. Sobald sie beendet ist, setzt das Programm seine Ausführung an der vorher unterbrochenen Stelle fort.

Genutzt werden Interrupts zum Beispiel von Ein- und Ausgabegeräten, wie Maus und Tastatur. Ohne Interrupts müssten alle Programme zyklisch nachfragen, ob es eine neue Eingabe gibt und diese dann entsprechend bearbeiten (sogenanntes Polling). Da ein Programm in dieser Zeit nichts anderes machen kann, ist diese Art der Abfrage höchst ineffizient.

Die am weitesten verbreitete Analogie zur Verdeutlichung des Prinzips ist eine Wohnungstür mit Klingel. Man kann den ganzen Tag in der Wohnung seinen Aufgaben nachgehen und zwischendurch klingeln Gäste, mit denen man sich dann kurz beschäftigt. Das klingeln ist hier also der Interrupt. Dann kann man wieder weiter mit der Arbeit machen bis der nächste klingelt. Hat man nun aber keine Klingel, so muss man ständig zur Tür rennen und nachsehen, ob eventuell jemand dort steht und gerne hereinkommen möchte (Polling).

An dieser Analogie kann man auch erkennen, dass Interrupts zusätzliche Hardware (eine Klingel) erfordern.


\subsubsection{FIFO Speicher}

BILD??\\

Ein FIFO (First In First Out) ist ein Speicherverfahren, bei dem die Elemente, die als erstes gespeichert werden, auch als erstes wieder entnommen werden. Es wird auch als Warteschlangenprinzip bezeichnet und in vielen Bereichen der Datenverarbeitung verwendet. Besonders bei Schnittstellen und Kommunikationsprotokollen ist es wichtig, dass die Daten in der Reihenfolge verarbeiten werden, in der sie angekommen sind, beziehungsweise abgesendet wurden. Das gegensätzliche Prinzip ist das LIFO (Last In First Out), auch Stapelprinzip (engl. Stack) genannt.\\

Im AD-Wandler sorgt der FIFO dafür, dass wirklich alle digitalisierten Samples vom Computer gespeichert werden, auch wenn dieser aufgrund von starker Prozesserbelastung nicht in der Lage ist diese sofort zu verarbeiten. Die digitalisierten Daten werden unabhängig vom PC immer sofort in den FIFO gespeichert und können dort angefordert werden. Ein Problem ergibt sich erst wenn der PC die Sample so langsam ausliest, dass der FIFO Speicher voll wird. In diesem Fall spricht man von einem Speicherüberlauf und bereits aufgenommene Daten werden überschrieben.\\


Zusammen mit Interrupts erlaubt der FIFO Speicher eine konstante Messwertdigitalisierung mit hoher Frequenz, ohne den Prozessor des PCs zu stark zu beanspruchen. Dazu werden die Daten kontinuierlich vom Board in den FIFO geschrieben und sobald ein festgelegter Grenzwert (threshold) erreicht ist, löst es einen Interrupt aus. Darauf reagiert nun der PC, indem er das komplette Datenpaket auf einmal (also so viele Samples, wie der threshold Wert eingestellt ist) aus dem FIFO liest und auf seine Festplatte speichert. Währenddessen werden weiterhin Daten digitalisiert und es geht kein Sample verloren.

Würde bei jedem neuen Sample ein Interrupt ausgelöst werden und die Daten jedes Mal einzeln abgerufen und gespeichert, so würde dies bei hohen Abtastfrequenzen zu extremer Prozessorbelastung führen. Der FIFO dient also gleichzeitig auch zur Verringerung der Interrupt Rate:

\begin{equation}
Interrupt ~Rate = \frac{A/D ~Frequenz \cdot Anzahl ~der ~aufgenommenen ~Kanaele}{FIFO ~threshold}
\end{equation}

Bei einem Kanal und einer Abtastfrequenz von $100000 Hz$ resultiert, bei einem threshold von 256, ein Unterschied von $100000$ zu ca. $391$ Interrupts pro Sekunde.


\subsection{Programmcode}

Für das Diamond Board existiert die \textit{Universal Driver Software}\footnote{http://www.diamondsystems.com/products/dscud}, eine C-basierte Programmbibliothek, die eine große Zahl von Funktionen zur Datenaquisition zur Verfügung stellt. Die Low-Level-Programmierung, bei der auf die einzelnen Register zugegriffen wird, entfällt damit weitgehend. 



\section{Experimente am Geomatikum}


\section{Verbesserungen}

bessere Zeitstempel, nicht nur 3 Mal pro Sekunde

\clearpage
\newpage
\singlespacing
\appendix
\bibliographystyle{plainnat}
\bibliography{bachelor}









\end{document}
